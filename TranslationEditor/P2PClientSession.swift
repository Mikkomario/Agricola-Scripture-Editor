//
//  P2PClientSession.swift
//  TranslationEditor
//
//  Created by Mikko Hilpinen on 27.3.2017.
//  Copyright Â© 2017 Mikko Hilpinen. All rights reserved.
//

import Foundation
import QRCode

// This information can be used for connecting with peer hosts
struct P2PConnectionInformation
{
	// ATTRIBUTES	--------------
	
	var serverURL: String
	var userName: String
	var password: String
	var projectId: String
	
	
	// COMPUTED PROPERTIES	-----
	
	// A string compression of the information
	var stringRepresentation: String
	{
		return "\(serverURL)#\(userName)#\(password)#\(projectId)"
	}
	
	// A QR code representation of this information
	var qrCode: QRCode?
	{
		return QRCode(stringRepresentation)
	}
	
	
	// INIT	---------------------
	
	// Parses the information from a string generated by stringRepresentation -function
	static func parse(from string: String) -> P2PConnectionInformation?
	{
		let components = string.components(separatedBy: "#")
		
		guard components.count == 4 else
		{
			return nil
		}
		
		return P2PConnectionInformation(serverURL: components[0], userName: components[1], password: components[2], projectId: components[3])
	}
}

// This class handles connection between P2P client and host
// Only a single session is used at a time
class P2PClientSession: ConnectionListener
{
	// ATTRIBUTES	--------------
	
	private(set) static var instance: P2PClientSession?
	
	let projectId: String
	
	private(set) var status: ConnectionStatus
	
	
	// COMPUTED PROPERTIES	------
	
	// Checks whether there is a currently active connection in place
	static var isConnected: Bool
	{
		return instance.exists { $0.status != .disconnected }
	}
	
	
	// INIT	----------------------
	
	private init(_ info: P2PConnectionInformation)
	{
		self.projectId = info.projectId
		self.status = .connecting
		
		// Starts online connection and listens for the new status
		ConnectionManager.instance.connect(serverURL: info.serverURL, userName: info.userName, password: info.password, continuous: true)
		ConnectionManager.instance.registerListener(self)
	}
	
	
	// IMPLEMENTED METHODS	-------
	
	func onConnectionStatusChange(newStatus status: ConnectionStatus)
	{
		self.status = status
		
		// Terminates the session when the connection disconnects
		if status == .disconnected
		{
			P2PClientSession.instance = nil
		}
	}
	
	func onConnectionProgressUpdate(transferred: Int, of total: Int, progress: Double)
	{
		// Doesn't need to react to progress updates
	}
	
	
	// OTHER METHODS	----------
	
	// Starts a new P2P session. If there was a previous session in place, terminates it
	static func start(_ info: P2PConnectionInformation)
	{
		instance = P2PClientSession(info)
	}
	
	// Stops the ongoing P2P session, if there is one in place
	static func stop()
	{
		if isConnected
		{
			ConnectionManager.instance.disconnect()
		}
		
		instance = nil
	}
}
